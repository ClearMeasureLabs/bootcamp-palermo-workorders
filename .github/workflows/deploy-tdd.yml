name: Deploy to TDD
run-name: "TDD Deploy • ${{ github.event.workflow_run.head_branch }} • 1.3.${{ github.event.workflow_run.run_number }}"
on:
  workflow_run:
    workflows: ["Integration Build"]
    types: [completed]
env:
  MAJOR_VERSION: 1
  MINOR_VERSION: 3

jobs:
  deploy-to-tdd:
    name: TDD
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    concurrency:
      # This will protect deployments - there should be no cancellation.
      group: deploy-to-tdd-serialized
      cancel-in-progress: false
    runs-on: windows-latest
    permissions:
      contents: read
      statuses: write
    environment:
      name: TDD

    steps:
      - name: Report TDD status as pending
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: pwsh
        run: |
          $sha = "${{ github.event.workflow_run.head_sha }}"
          $runUrl = "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          gh api "repos/${{ github.repository }}/statuses/$sha" `
            -f state="pending" `
            -f target_url="$runUrl" `
            -f description="TDD deployment in progress" `
            -f context="Deploy to TDD"

      - uses: actions/checkout@v6.0.1
        with:
          ref: ${{ github.event.workflow_run.head_sha }}

      - name: Setup .NET SDK 10.0.100
        uses: actions/setup-dotnet@v5.0.1
        with:
          dotnet-version: '10.0.100'
      - name: Setup .NET SDK 6.0
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '6.0.x'

      # Configure NuGet authentication for ClearMeasureLabs feed
      - name: Authenticate to ClearMeasureLabs NuGet feed
        shell: pwsh
        run: |
          # Remove existing source to avoid encryption issues
          dotnet nuget remove source ClearMeasureLabs 2>$null
          if ($LASTEXITCODE -ne 0) { $LASTEXITCODE = 0 }
          # Add source with credentials and clear-text password storage
          dotnet nuget add source https://nuget.pkg.github.com/ClearMeasureLabs/index.json `
            --name ClearMeasureLabs `
            --username ${{ github.actor }} `
            --password ${{ secrets.CLEARMEASURELABS_NUGET_PAT }} `
            --store-password-in-clear-text


      - name: Set Version
        shell: pwsh
        run: |
          $version = "${{ env.MAJOR_VERSION }}.${{ env.MINOR_VERSION }}.${{ github.event.workflow_run.run_number }}"
          "BUILD_BUILDNUMBER=$version" >> $env:GITHUB_ENV
          "VERSION=$version" >> $env:GITHUB_ENV
          Write-Host "Build version: $version"

      - name: Create Octopus Release
        id: create-octopus-release
        uses: OctopusDeploy/create-release-action@v3
        env:
          OCTOPUS_API_KEY: ${{ secrets.OCTO_API_KEY }}
          OCTOPUS_URL: ${{ secrets.OCTOPUS_URL }}
          OCTOPUS_SPACE: ${{ vars.OCTOPUS_SPACE }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          BUILD_BUILDNUMBER: ${{ env.VERSION }}
        with:
          project: '${{ vars.OCTOPUS_PROJECT }}'
          release_number: "${{ env.VERSION }}"
          git_ref: ${{ github.event.workflow_run.head_branch }}
          git_commit: ${{ github.event.workflow_run.head_sha }}

      - name: Deploy Octopus Release to TDD
        id: start-deploy-to-tdd
        uses: OctopusDeploy/deploy-release-action@v3
        env:
          OCTOPUS_API_KEY: ${{ secrets.OCTO_API_KEY }}
          OCTOPUS_URL: ${{ secrets.OCTOPUS_URL }}
          OCTOPUS_SPACE: ${{ vars.OCTOPUS_SPACE }}
          BUILD_BUILDNUMBER: ${{ env.VERSION }}
        with:
          project: ${{ vars.OCTOPUS_PROJECT }}
          release_number: ${{ env.VERSION }}
          environments: "TDD"

      - name: Wait for the TDD deployment to complete
        uses: OctopusDeploy/await-task-action@v3
        env:
          OCTOPUS_API_KEY: ${{ secrets.OCTO_API_KEY  }}
          OCTOPUS_URL: ${{ secrets.OCTOPUS_URL }}
          OCTOPUS_SPACE: ${{ vars.OCTOPUS_SPACE }}
        with:
          server_task_id: ${{ fromJson(steps.start-deploy-to-tdd.outputs.server_tasks)[0].serverTaskId }}
          timeout_after: 1800

      - name: Login to Azure
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get Container App FQDN and Connection String
        shell: pwsh
        run: |
          $containerAppFqdn = az containerapp show `
            --name ${{ vars.CONTAINER_APP_NAME }} `
            --resource-group ${{ vars.TDD_RESOURCE_GROUP_NAME}} `
            --query properties.configuration.ingress.fqdn `
            -o tsv

          if ([string]::IsNullOrWhiteSpace($containerAppFqdn)) {
            Write-Error "Error: Could not retrieve container app FQDN"
            exit 1
          }

          $containerAppUrl = "https://$containerAppFqdn"
          Write-Host "Container App FQDN: $containerAppFqdn"
          Write-Host "Container App URL: $containerAppUrl"
          "CONTAINER_APP_URL=$containerAppUrl" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
          "ApplicationBaseUrl=$containerAppUrl" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8

          # Get the connection string from container app environment variables
          $containerAppConnectionString = az containerapp show `
            --name ${{ vars.CONTAINER_APP_NAME }} `
            --resource-group ${{ vars.TDD_RESOURCE_GROUP_NAME}} `
            --query "properties.template.containers[0].env[?name=='ConnectionStrings__SqlConnectionString'].value" `
            -o tsv
          Write-Host "Container App Connection String retrieved: $([string]::IsNullOrWhiteSpace($containerAppConnectionString))"
          "ConnectionStrings__SqlConnectionString=$containerAppConnectionString" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
          "CONTAINER_APP_CONNECTION_STRING=$containerAppConnectionString" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8

      - name: Wait for Container App to become healthy
        shell: pwsh
        run: |
          $url = "${{ env.CONTAINER_APP_URL }}/_healthcheck"
          $maxAttempts = 30
          $delaySeconds = 10
          Write-Host "Polling $url for healthy response (max ${maxAttempts} attempts, ${delaySeconds}s apart)..."
          for ($i = 1; $i -le $maxAttempts; $i++) {
            try {
              $response = Invoke-WebRequest -Uri $url -UseBasicParsing -TimeoutSec 15
              $body = $response.Content
              Write-Host "Attempt ${i}: HTTP $($response.StatusCode) - $body"
              if ($response.StatusCode -eq 200 -and $body -match 'Healthy') {
                Write-Host "Container App is healthy after $i attempts."
                exit 0
              }
            } catch {
              Write-Host "Attempt ${i}: $($_.Exception.Message)"
            }
            if ($i -lt $maxAttempts) { Start-Sleep -Seconds $delaySeconds }
          }
          Write-Error "Container App did not become healthy after $maxAttempts attempts."
          exit 1

      - name: Run Acceptance tests
        if: success()
        shell: pwsh
        env:
          BUILD_BUILDNUMBER: ${{ env.VERSION }}
          BuildConfiguration: Release
          ConnectionStrings__SqlConnectionString: ${{ env.CONTAINER_APP_CONNECTION_STRING }}
          ApplicationBaseUrl: ${{ env.CONTAINER_APP_URL }}
          StartLocalServer: "false"
          TEST_INPUT_DELAY_MS: "1500"

        run: |

          . .\build.ps1
          $verbosity = "normal"
          $base_dir = resolve-path .\
          $source_dir = Join-Path $base_dir "src"
          $test_dir = Join-Path (Join-Path $base_dir "build") "test"
          $acceptanceTestProjectPath = Join-Path $source_dir "AcceptanceTests"
          $acceptanceTestProject = Join-Path $acceptanceTestProjectPath "AcceptanceTests.csproj"
          $runSettingsPath = Join-Path $acceptanceTestProjectPath "AcceptanceTests.runsettings"
          $resultsDirectory = Join-Path $test_dir "AcceptanceTests"


          # Build the solution first (since AcceptanceTests uses --no-build)
          # This restore/build ensures Playwright tooling is ready
          dotnet build src/ChurchBulletin.sln --configuration ${{ env.BuildConfiguration }}

          Push-Location -Path $acceptanceTestProjectPath
          try {
              $playwrightScript = Join-PathSegments "bin" "Release" "net10.0" "playwright.ps1"

              if (Test-Path $playwrightScript) {
                  # Resolve to absolute path
                  $playwrightScript = Resolve-Path $playwrightScript
                  Write-Host "Installing Playwright browsers from $playwrightScript"
                  & pwsh $playwrightScript install --with-deps
                  if ($LASTEXITCODE -ne 0) {
                      throw "Failed to install Playwright browsers"
                  }
              } else {
                  Write-Warning "Playwright script not found at $playwrightScript"
              }
          } finally {
              Pop-Location
          }


          # Now run the acceptance tests
          Write-Host "Running acceptance tests on TDD at ${{ env.ApplicationBaseUrl }}, settings file: $runSettingsPath"

          # Re-set environment variables after build.ps1 cleared them
          $env:ConnectionStrings__SqlConnectionString = "${{ env.CONTAINER_APP_CONNECTION_STRING }}"
          $env:ApplicationBaseUrl = "${{ env.CONTAINER_APP_URL }}"
          $env:StartLocalServer = "false"
          $env:TEST_INPUT_DELAY_MS = "${{ env.TEST_INPUT_DELAY_MS }}"

          dotnet test $acceptanceTestProject /p:CopyLocalLockFileAssemblies=true --nologo `
            --no-restore --logger:trx --results-directory $resultsDirectory --no-build `
            -v $verbosity --configuration ${{ env.BuildConfiguration }} --settings:$runSettingsPath `
            --collect:"XPlat Code Coverage"


      - name: Upload Acceptance Test Results
        uses: actions/upload-artifact@v4
        with:
          name: acceptance-test-results-tdd
          path: build/test/AcceptanceTests/**/*.trx
          retention-days: 2

      - name: Report TDD status to commit
        if: always()
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: pwsh
        run: |
          $sha = "${{ github.event.workflow_run.head_sha }}"
          $runUrl = "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          $jobStatus = "${{ job.status }}"

          if ($jobStatus -eq "success") {
            $state = "success"
            $description = "TDD deployment and acceptance tests passed"
          } else {
            $state = "failure"
            $description = "TDD deployment or acceptance tests failed"
          }

          gh api "repos/${{ github.repository }}/statuses/$sha" `
            -f state="$state" `
            -f target_url="$runUrl" `
            -f description="$description" `
            -f context="Deploy to TDD"
