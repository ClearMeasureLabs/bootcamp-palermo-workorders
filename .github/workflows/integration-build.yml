name: Integration Build

on:
  push:
    branches: ['*']
  pull_request:
    branches: ['*']
  workflow_dispatch:

env:
  MAJOR_VERSION: 1
  MINOR_VERSION: 3

jobs:
  build-linux:
    name: Build and Test on Linux
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    env:
      BUILD_CONFIGURATION: Release
    
    steps:
      # Checkout code
      - name: Checkout code
        uses: actions/checkout@v4

      # Install .NET SDK 10.0.100
      - name: Setup .NET SDK 10.0.100
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '10.0.100'

      # Install .NET SDK 6.0 (required by Octopus CLI tool - includes runtime)
      - name: Setup .NET SDK 6.0
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '6.0.x'

      # Verify .NET 6.0 runtime is available (required by dotnet-octo tool)
      - name: Verify .NET 6.0 runtime
        run: |
          echo "Installed runtimes:"
          dotnet --list-runtimes
          echo ""
          echo "Checking for .NET 6.0 runtime:"
          if dotnet --list-runtimes | grep -q "Microsoft.NETCore.App 6.0"; then
            echo "✓ .NET 6.0 runtime is available"
          else
            echo "✗ .NET 6.0 runtime not found - attempting to install runtime explicitly"
            # Try installing runtime explicitly if SDK installation didn't include it
            curl -sSL https://dot.net/v1/dotnet-install.sh | bash /dev/stdin --runtime dotnet --version 6.0.0
            export PATH="$HOME/.dotnet:$PATH"
            dotnet --list-runtimes
          fi

      # Set version environment variable
      - name: Set Version
        run: |
          version="${{ env.MAJOR_VERSION }}.${{ env.MINOR_VERSION }}.${{ github.run_number }}"
          echo "BUILD_BUILDNUMBER=$version" >> $GITHUB_ENV
          echo "VERSION=$version" >> $GITHUB_ENV
          echo "Build version: $version"

      - name: Run CI Build 
        shell: pwsh
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          BUILD_BUILDNUMBER: ${{ env.VERSION }}
        run: |
          . ./build.ps1
          Invoke-CIBuild

      # Publish test results
      - name: Test Reporter
        uses: dorny/test-reporter@v2.1.1
        if: always()
        with:
          name: Linux CI Test Results
          path: 'build/test/**/*.trx'
          reporter: dotnet-trx

      # Publish code coverage
      - name: Publish Code Coverage
        uses: codecov/codecov-action@v4
        if: always()
        with:
          files: '**/build/test/**/In/**/coverage.cobertura.xml'
          flags: unittests-linux
          name: codecov-linux

      # Upload test results as artifacts
      - name: Upload Test Results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results-linux
          path: build/test/**/*.trx
          retention-days: 30

      # Upload code coverage as artifacts
      - name: Upload Code Coverage
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: code-coverage-linux
          path: '**/build/test/**/In/**/coverage.cobertura.xml'
          retention-days: 30

      # Package Everything as NuGet Packages
      - name: Create NuGet Packages
        shell: pwsh
        env:
          BUILD_BUILDNUMBER: ${{ env.VERSION }}
        run: |
          . ./build.ps1
          Package-Everything

      # Upload packages as artifacts
      - name: Upload NuGet Packages
        uses: actions/upload-artifact@v4
        if: success()
        with:
          name: nuget-packages-acceptance
          path: build/*.nupkg
          retention-days: 90

  run-acceptance-tests:
      name: Run Acceptance Tests
      runs-on: ubuntu-latest
      needs: [build-linux]
      if: success()
      permissions:
        contents: read
        packages: write
      
      steps:
        # Checkout code
        - name: Checkout code
          uses: actions/checkout@v4

        # Install .NET SDK 10.0.100
        - name: Setup .NET SDK 10.0.100
          uses: actions/setup-dotnet@v4
          with:
            dotnet-version: '10.0.100'

        # Install .NET SDK 6.0 (required by Octopus CLI tool - includes runtime)
        - name: Setup .NET SDK 6.0
          uses: actions/setup-dotnet@v4
          with:
            dotnet-version: '6.0.x'

        # Verify .NET 6.0 runtime is available (required by dotnet-octo tool)
        - name: Verify .NET 6.0 runtime
          run: |
            echo "Installed runtimes:"
            dotnet --list-runtimes
            echo ""
            echo "Checking for .NET 6.0 runtime:"
            if dotnet --list-runtimes | grep -q "Microsoft.NETCore.App 6.0"; then
              echo "✓ .NET 6.0 runtime is available"
            else
              echo "✗ .NET 6.0 runtime not found - attempting to install runtime explicitly"
              # Try installing runtime explicitly if SDK installation didn't include it
              curl -sSL https://dot.net/v1/dotnet-install.sh | bash /dev/stdin --runtime dotnet --version 6.0.0
              export PATH="$HOME/.dotnet:$PATH"
              dotnet --list-runtimes
            fi

        # Set version environment variable
        - name: Set Version
          run: |
            version="${{ env.MAJOR_VERSION }}.${{ env.MINOR_VERSION }}.${{ github.run_number }}"
            echo "BUILD_BUILDNUMBER=$version" >> $GITHUB_ENV
            echo "VERSION=$version" >> $GITHUB_ENV
            echo "Build version: $version"

        # Run Acceptance Tests
        - name: Run Acceptance Tests
          shell: pwsh
          env:
            BuildConfiguration: Release
            BUILD_BUILDNUMBER: ${{ env.VERSION }}
          run: |
            .\AcceptanceTests.ps1

        # Upload test results
        - name: Upload Test Results
          uses: actions/upload-artifact@v4
          if: always()
          with:
            name: test-results-acceptance
            path: build/test/**/*.trx
            retention-days: 30


  docker-build-image-for-churchbulletin-ui:
    name: Create and push Docker image for ChurchBulletin.UI
    needs: [build-linux, run-acceptance-tests]
    if: success()
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: read
    
    steps:
      # Checkout code
      - name: Checkout code
        uses: actions/checkout@v4

      # Set version environment variable (same as build-linux job)
      - name: Set Version
        run: |
          version="${{ env.MAJOR_VERSION }}.${{ env.MINOR_VERSION }}.${{ github.run_number }}"
          echo "BUILD_BUILDNUMBER=$version" >> $GITHUB_ENV
          echo "VERSION=$version" >> $GITHUB_ENV
          echo "Build version: $version"

      # Install .NET SDK 10.0.100
      - name: Setup .NET SDK 10.0.100
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '10.0.100'


      # Download NuGet packages from build-linux job
      - name: Download NuGet Packages
        uses: actions/download-artifact@v4
        with:
          name: nuget-packages-acceptance
          path: ./packages

      # Extract ChurchBulletin.UI NuGet package
      - name: Extract UI NuGet Package
        run: |
          # Find the ChurchBulletin.UI package
          PACKAGE_FILE=$(find ./packages -name "ChurchBulletin.UI.*.nupkg" | head -n 1)
          
          if [ -z "$PACKAGE_FILE" ]; then
            echo "Error: ChurchBulletin.UI package not found"
            ls -la ./packages/
            exit 1
          fi
          
          echo "Found package: $PACKAGE_FILE"
          
          # Create temporary extraction directory
          mkdir -p ./package-extract
          
          # Extract the Octopus package (it's a ZIP file)
          # Use -o to overwrite without prompting
          unzip -o "$PACKAGE_FILE" -d ./package-extract
          
          # Fix permissions on extracted files before copying
          # First, ensure directories are accessible
          find ./package-extract -type d -exec chmod u+rwx {} \;
          # Then ensure files are readable
          find ./package-extract -type f -exec chmod u+r {} \;
          
          # Create built directory (where Dockerfile expects files)
          mkdir -p ./built
          
          # Octopus packages may have files directly in root or nested
          # Look for the DLL file to determine structure
          DLL_PATH=$(find ./package-extract -name "ClearMeasure.Bootcamp.UI.Server.dll" 2>/dev/null | head -n 1)
          
          if [ -z "$DLL_PATH" ]; then
            echo "Error: ClearMeasure.Bootcamp.UI.Server.dll not found in package"
            echo "Package contents:"
            find ./package-extract -type f 2>/dev/null | head -20
            exit 1
          fi
          
          # Get the directory containing the DLL
          DLL_DIR=$(dirname "$DLL_PATH")
          
          # Copy all contents from the DLL's directory to built using tar
          # tar handles permissions and file types (files/directories/symlinks) correctly
          (cd "$DLL_DIR" && tar cf - .) | (cd ./built && tar xf -)
          
          # Remove any package metadata files that might have been copied
          find ./built -name "*.nuspec" -delete 2>/dev/null || true
          find ./built -name "[Content_Types].xml" -delete 2>/dev/null || true
          find ./built -name "*.psmdcp" -delete 2>/dev/null || true
          find ./built -name "_rels" -type d -exec rm -rf {} + 2>/dev/null || true
          find ./built -path "*/package/services/metadata/*" -delete 2>/dev/null || true
          
          # Verify extracted files
          echo "Extracted files in built directory:"
          ls -la built/ | head -20
          
          # Verify we have the expected DLL
          if [ -f ./built/ClearMeasure.Bootcamp.UI.Server.dll ]; then
            echo "✓ Successfully extracted UI Server package"
          else
            echo "Error: ClearMeasure.Bootcamp.UI.Server.dll not found after extraction"
            exit 1
          fi
          
          # Clean up
          rm -rf ./package-extract ./packages

      # Build Docker image
      - name: Build Docker image
        run: |
          IMAGE_TAG="${{ env.BUILD_BUILDNUMBER }}"
          docker build -f Dockerfile -t churchbulletingithubacr.azurecr.io/churchbulletin.ui:${IMAGE_TAG} .
          docker tag churchbulletingithubacr.azurecr.io/churchbulletin.ui:${IMAGE_TAG} churchbulletingithubacr.azurecr.io/churchbulletin.ui:latest

      # Login to Azure
      - name: Login to Azure
        uses: azure/login@v1
        with:
          # TODO:  Need to create the AZURE_CREDENTIALS secret in the GitHub repository.
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      # Login to Azure Container Registry
      - name: Login to ACR
        run: |
          az acr login --name churchbulletingithubacr

      # Push Docker image to ACR
      - name: Push Docker image to ACR
        run: |
          IMAGE_TAG="${{ env.BUILD_BUILDNUMBER }}"
          docker push churchbulletingithubacr.azurecr.io/churchbulletin.ui:${IMAGE_TAG}
          docker push churchbulletingithubacr.azurecr.io/churchbulletin.ui:latest
          

  deploy-to-tdd:
    name: Deploy to TDD environment and run acceptance tests
    needs: [docker-build-image-for-churchbulletin-ui]
    if: success() # Only run if Docker build image job completed successfully
    runs-on: ubuntu-latest
    environment:
      name: TDD
    
    steps:
      # Set version environment variable
      - name: Set Version
        run: |
          version="${{ env.MAJOR_VERSION }}.${{ env.MINOR_VERSION }}.${{ github.run_number }}"
          echo "BUILD_BUILDNUMBER=$version" >> $GITHUB_ENV
          echo "VERSION=$version" >> $GITHUB_ENV
          echo "Build version: $version"

      # Set TDD environment variables
      - name: Set TDD Environment Variables
        run: |
          echo "TDD_RESOURCE_GROUP=bootcamp-tdd" >> $GITHUB_ENV
          echo "TDD_APP_NAME=ui-gh" >> $GITHUB_ENV

      # Install .NET SDK 6.0 (required by Octopus CLI tool - includes runtime)
      - name: Setup .NET SDK 6.0
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '6.0.x'

      # Verify .NET 6.0 runtime is available (required by dotnet-octo tool)
      - name: Verify .NET 6.0 runtime
        run: |
          echo "Installed runtimes:"
          dotnet --list-runtimes
          echo ""
          echo "Checking for .NET 6.0 runtime:"
          if dotnet --list-runtimes | grep -q "Microsoft.NETCore.App 6.0"; then
            echo "✓ .NET 6.0 runtime is available"
          else
            echo "✗ .NET 6.0 runtime not found - attempting to install runtime explicitly"
            # Try installing runtime explicitly if SDK installation didn't include it
            curl -sSL https://dot.net/v1/dotnet-install.sh | bash /dev/stdin --runtime dotnet --version 6.0.0
            export PATH="$HOME/.dotnet:$PATH"
            dotnet --list-runtimes
          fi

      - name: Install Octopus CLI
        uses: OctopusDeploy/install-octopus-cli-action@v1
        with:
          version: latest

      - name: Create release and deploy to TDD
        uses: OctopusDeploy/create-release-action@v1
        with:
          api_key: ${{ secrets.OCTO_API_KEY }}
          server: ${{ secrets.OCTOPUS_URL }}
          space: ${{ vars.OCTOPUS_SPACE }}       
          project: ${{ vars.OCTOPUS_PROJECT }}
          deploy_to: "TDD"
          deployment_timeout: 00:30:00   
          progress: true 
          release_number: ${{ env.BUILD_BUILDNUMBER }}

      - name: 'Login via Azure CLI'
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
    
      - name: Get Container App URL
        run: |
          # Configure Azure CLI to use dynamic extension installation
          az config set extension.use_dynamic_install=yes_without_prompt
          
          # Get the Container App URL
          CONTAINER_APP_URL=$(az containerapp show \
            --resource-group ${{ env.TDD_RESOURCE_GROUP }} \
            --name ${{ env.TDD_APP_NAME }} \
            --query properties.configuration.ingress.fqdn \
            --output tsv)
          
          # Remove quotes if present and set as environment variable
          CONTAINER_APP_URL=$(echo "$CONTAINER_APP_URL" | tr -d '"')
          echo "CONTAINER_APP_URL=$CONTAINER_APP_URL" >> $GITHUB_ENV
          echo "Container App URL: $CONTAINER_APP_URL"

      # Download acceptance test package from artifacts (created by build-linux job)
      # This approach uses GitHub Actions artifacts instead of NuGet CLI, eliminating
      # the need to install external tools and providing better reliability
      - name: Download Acceptance Test Package
        uses: actions/download-artifact@v4
        with:
          name: nuget-packages-acceptance
          path: ./packages

      - name: Extract Acceptance Test Package
        run: |
          # Find the ChurchBulletin.AcceptanceTests package
          PACKAGE_FILE=$(find ./packages -name "ChurchBulletin.AcceptanceTests.*.nupkg" | head -n 1)
          
          if [ -z "$PACKAGE_FILE" ]; then
            echo "Error: ChurchBulletin.AcceptanceTests package not found"
            ls -la ./packages/
            exit 1
          fi
          
          echo "Found package: $PACKAGE_FILE"
          
          # Create directory for extraction
          mkdir -p ./acceptance-tests-extract
          
          # Extract the package (NuGet packages are ZIP files)
          unzip -o "$PACKAGE_FILE" -d ./acceptance-tests-extract
          
          # Fix permissions on extracted files
          find ./acceptance-tests-extract -type d -exec chmod u+rwx {} \;
          find ./acceptance-tests-extract -type f -exec chmod u+r {} \;
          
          # Create the expected directory structure for VSTest
          mkdir -p ./ChurchBulletin.AcceptanceTests.${{ env.BUILD_BUILDNUMBER }}
          
          # Find the test DLL to determine package structure
          # dotnet-octo pack packages files from the publish directory
          TEST_DLL=$(find ./acceptance-tests-extract -name "*AcceptanceTests.dll" 2>/dev/null | head -n 1)
          
          if [ -z "$TEST_DLL" ]; then
            echo "Error: AcceptanceTests DLL not found in package"
            echo "Package contents:"
            find ./acceptance-tests-extract -type f 2>/dev/null | head -20
            exit 1
          fi
          
          # Get the directory containing the test DLL
          TEST_DIR=$(dirname "$TEST_DLL")
          
          # Copy all contents from the test DLL's directory using tar
          # This preserves directory structure and handles all file types correctly
          (cd "$TEST_DIR" && tar cf - .) | (cd ./ChurchBulletin.AcceptanceTests.${{ env.BUILD_BUILDNUMBER }} && tar xf -)
          
          # Remove any package metadata files that might have been copied
          find ./ChurchBulletin.AcceptanceTests.${{ env.BUILD_BUILDNUMBER }} -name "*.nuspec" -delete 2>/dev/null || true
          find ./ChurchBulletin.AcceptanceTests.${{ env.BUILD_BUILDNUMBER }} -name "[Content_Types].xml" -delete 2>/dev/null || true
          find ./ChurchBulletin.AcceptanceTests.${{ env.BUILD_BUILDNUMBER }} -name "*.psmdcp" -delete 2>/dev/null || true
          find ./ChurchBulletin.AcceptanceTests.${{ env.BUILD_BUILDNUMBER }} -name "_rels" -type d -exec rm -rf {} + 2>/dev/null || true
          
          # Verify we have test DLLs
          TEST_DLL_COUNT=$(find ./ChurchBulletin.AcceptanceTests.${{ env.BUILD_BUILDNUMBER }} -name "*AcceptanceTests.dll" | wc -l)
          if [ "$TEST_DLL_COUNT" -eq 0 ]; then
            echo "Error: No AcceptanceTests.dll files found after extraction"
            echo "Contents:"
            find ./ChurchBulletin.AcceptanceTests.${{ env.BUILD_BUILDNUMBER }} -type f | head -20
            exit 1
          else
            echo "✓ Found $TEST_DLL_COUNT AcceptanceTests DLL file(s)"
          fi
          
          # Clean up
          rm -rf ./acceptance-tests-extract ./packages
          echo "✓ Acceptance test package extracted successfully"

      - name: Run tests
        uses: microsoft/vstest-action@v1.0.0
        with:
          testAssembly: |
            **/*AcceptanceTests.dll
            !**/*TestAdapter.dll
            !**/obj/**
          searchFolder: ./ChurchBulletin.AcceptanceTests.${{ env.BUILD_BUILDNUMBER }}/
          runInParallel: false 


  deploy-to-uat:
    name: Deploy to UAT environment
    needs: [deploy-to-tdd]
    if: success() # Only run if TDD job completed successfully
    runs-on: ubuntu-latest
    environment:
      name: UAT
    
    steps:
      # Set version environment variable (must match TDD job)
      - name: Set Version
        run: |
          version="${{ env.MAJOR_VERSION }}.${{ env.MINOR_VERSION }}.${{ github.run_number }}"
          echo "BUILD_BUILDNUMBER=$version" >> $GITHUB_ENV
          echo "VERSION=$version" >> $GITHUB_ENV
          echo "Build version: $version"
          echo "Deploying release $version to UAT (same release that was deployed to TDD)"

      # Install .NET SDK 10.0.100 (required for running Database migration tool)
      - name: Setup .NET SDK 10.0.100
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '10.0.100'

      - name: Install Octopus CLI
        uses: OctopusDeploy/install-octopus-cli-action@v1
        with:
          version: latest

      - name: Download ChurchBulletin.Database NuGet Package
        uses: actions/download-artifact@v4
        with:
          name: nuget-packages-acceptance
          path: ./packages

      - name: Extract Database Package and Apply Migrations
        run: |
          # Find the ChurchBulletin.Database package
          PACKAGE_FILE=$(find ./packages -name "ChurchBulletin.Database.*.nupkg" | head -n 1)
          
          if [ -z "$PACKAGE_FILE" ]; then
            echo "Error: ChurchBulletin.Database package not found"
            ls -la ./packages/
            exit 1
          fi
          
          echo "Found package: $PACKAGE_FILE"
          
          # Create temporary extraction directory
          mkdir -p ./database-extract
          
          # Extract the package (NuGet packages are ZIP files)
          unzip -o "$PACKAGE_FILE" -d ./database-extract
          
          # Fix permissions on extracted files
          find ./database-extract -type d -exec chmod u+rwx {} \;
          find ./database-extract -type f -exec chmod u+r {} \;
          
          # Find the Database DLL
          DATABASE_DLL=$(find ./database-extract -name "ClearMeasure.Bootcamp.Database.dll" | head -n 1)
          
          if [ -z "$DATABASE_DLL" ]; then
            echo "Error: ClearMeasure.Bootcamp.Database.dll not found in package"
            find ./database-extract -name "*.dll" | head -10
            exit 1
          fi
          
          echo "Found Database DLL: $DATABASE_DLL"
          
          # Find the scripts directory
          SCRIPTS_DIR=$(find ./database-extract -type d -name "scripts" | head -n 1)
          
          if [ -z "$SCRIPTS_DIR" ]; then
            # Scripts might be in the root or in a specific location
            # Try looking for the Update subdirectory
            SCRIPTS_DIR=$(find ./database-extract -type d -name "Update" | head -n 1)
            if [ -n "$SCRIPTS_DIR" ]; then
              SCRIPTS_DIR=$(dirname "$SCRIPTS_DIR")
            fi
          fi
          
          if [ -z "$SCRIPTS_DIR" ]; then
            echo "Warning: Scripts directory not found, using package root"
            SCRIPTS_DIR="./database-extract"
          fi
          
          echo "Using scripts directory: $SCRIPTS_DIR"
          
          # Get database connection details from secrets
          # Configure these secrets in GitHub Settings → Secrets and variables → Actions → Secrets
          DATABASE_SERVER="${{ secrets.UAT_DATABASE_SERVER }}"
          DATABASE_NAME="${{ secrets.UAT_DATABASE_NAME }}"
          DATABASE_USER="${{ secrets.UAT_DATABASE_USER }}"
          DATABASE_PASSWORD="${{ secrets.UAT_DATABASE_PASSWORD }}"
          
          # Use default database name if not provided
          if [ -z "$DATABASE_NAME" ]; then
            DATABASE_NAME="ChurchBulletin"
          fi
          
          if [ -z "$DATABASE_SERVER" ]; then
            echo "Error: Database server not configured. Set UAT_DATABASE_SERVER secret in GitHub Settings."
            exit 1
          fi
          
          # Require SQL Server authentication for the UAT Database
          if [ -z "$DATABASE_USER" ] || [ -z "$DATABASE_PASSWORD" ]; then
            echo "Error: Database credentials required for the UAT Database."
            echo "Please configure UAT_DATABASE_USER and UAT_DATABASE_PASSWORD secrets in GitHub Settings."
            exit 1
          fi
          
          echo "Applying database migrations..."
          echo "Database Server: $DATABASE_SERVER"
          echo "Database Name: $DATABASE_NAME"
          echo "Database User: $DATABASE_USER"
          
          # Run the database update command with SQL Server authentication
          dotnet "$DATABASE_DLL" update "$DATABASE_SERVER" "$DATABASE_NAME" "$SCRIPTS_DIR" "$DATABASE_USER" "$DATABASE_PASSWORD"
          
          if [ $? -ne 0 ]; then
            echo "Error: Database migration failed"
            exit 1
          fi
          
          echo "✓ Database migrations completed successfully"
          
          # Clean up
          rm -rf ./database-extract ./packages

      - name: Deploy existing release to UAT
        uses: OctopusDeploy/create-release-action@v1
        with:
          api_key: ${{ secrets.OCTO_API_KEY }}
          server: ${{ secrets.OCTOPUS_URL }}
          space: ${{ vars.OCTOPUS_SPACE }}
          project: ${{ vars.OCTOPUS_PROJECT }}
          release_number: ${{ env.BUILD_BUILDNUMBER }}
          deploy_to: "UAT"
          progress: true
          deployment_timeout: 00:30:00
          # Note: This will deploy the existing release that was created during TDD deployment            

  deploy-to-prod:
    name: Deploy to Production environment
    needs: [deploy-to-uat]
    if: success() # Only run if UAT job completed successfully
    runs-on: ubuntu-latest
    environment:
      name: Prod
      # Note: Manual approval must be configured in GitHub Settings → Environments → Prod
      # Add required reviewers to enable manual approval before deployment
    
    steps:
      # Set version environment variable (must match TDD and UAT jobs)
      - name: Set Version
        run: |
          version="${{ env.MAJOR_VERSION }}.${{ env.MINOR_VERSION }}.${{ github.run_number }}"
          echo "BUILD_BUILDNUMBER=$version" >> $GITHUB_ENV
          echo "VERSION=$version" >> $GITHUB_ENV
          echo "Build version: $version"
          echo "Deploying release $version to Production (same release that was deployed to TDD and UAT)"

      # Install .NET SDK 10.0.100 (required for running Database migration tool)
      - name: Setup .NET SDK 10.0.100
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '10.0.100'

      - name: Install Octopus CLI
        uses: OctopusDeploy/install-octopus-cli-action@v1
        with:
          version: latest

      - name: Download ChurchBulletin.Database NuGet Package
        uses: actions/download-artifact@v4
        with:
          name: nuget-packages-acceptance
          path: ./packages

      - name: Extract Database Package and Apply Migrations
        run: |
          # Find the ChurchBulletin.Database package
          PACKAGE_FILE=$(find ./packages -name "ChurchBulletin.Database.*.nupkg" | head -n 1)
          
          if [ -z "$PACKAGE_FILE" ]; then
            echo "Error: ChurchBulletin.Database package not found"
            ls -la ./packages/
            exit 1
          fi
          
          echo "Found package: $PACKAGE_FILE"
          
          # Create temporary extraction directory
          mkdir -p ./database-extract
          
          # Extract the package (NuGet packages are ZIP files)
          unzip -o "$PACKAGE_FILE" -d ./database-extract
          
          # Fix permissions on extracted files
          find ./database-extract -type d -exec chmod u+rwx {} \;
          find ./database-extract -type f -exec chmod u+r {} \;
          
          # Find the Database DLL
          DATABASE_DLL=$(find ./database-extract -name "ClearMeasure.Bootcamp.Database.dll" | head -n 1)
          
          if [ -z "$DATABASE_DLL" ]; then
            echo "Error: ClearMeasure.Bootcamp.Database.dll not found in package"
            find ./database-extract -name "*.dll" | head -10
            exit 1
          fi
          
          echo "Found Database DLL: $DATABASE_DLL"
          
          # Find the scripts directory
          SCRIPTS_DIR=$(find ./database-extract -type d -name "scripts" | head -n 1)
          
          if [ -z "$SCRIPTS_DIR" ]; then
            # Scripts might be in the root or in a specific location
            # Try looking for the Update subdirectory
            SCRIPTS_DIR=$(find ./database-extract -type d -name "Update" | head -n 1)
            if [ -n "$SCRIPTS_DIR" ]; then
              SCRIPTS_DIR=$(dirname "$SCRIPTS_DIR")
            fi
          fi
          
          if [ -z "$SCRIPTS_DIR" ]; then
            echo "Warning: Scripts directory not found, using package root"
            SCRIPTS_DIR="./database-extract"
          fi
          
          echo "Using scripts directory: $SCRIPTS_DIR"
          
          # Get database connection details from secrets
          # Configure these secrets in GitHub Settings → Secrets and variables → Actions → Secrets
          DATABASE_SERVER="${{ secrets.PROD_DATABASE_SERVER }}"
          DATABASE_NAME="${{ secrets.PROD_DATABASE_NAME }}"
          DATABASE_USER="${{ secrets.PROD_DATABASE_USER }}"
          DATABASE_PASSWORD="${{ secrets.PROD_DATABASE_PASSWORD }}"
          
          # Use default database name if not provided
          if [ -z "$DATABASE_NAME" ]; then
            DATABASE_NAME="ChurchBulletin"
          fi
          
          if [ -z "$DATABASE_SERVER" ]; then
            echo "Error: Database server not configured. Set PROD_DATABASE_SERVER secret in GitHub Settings."
            exit 1
          fi
          
          # Require SQL Server authentication for the Production Database
          if [ -z "$DATABASE_USER" ] || [ -z "$DATABASE_PASSWORD" ]; then
            echo "Error: Database credentials required for the Production Database."
            echo "Please configure PROD_DATABASE_USER and PROD_DATABASE_PASSWORD secrets in GitHub Settings."
            exit 1
          fi
          
          echo "Applying database migrations..."
          echo "Database Server: $DATABASE_SERVER"
          echo "Database Name: $DATABASE_NAME"
          echo "Database User: $DATABASE_USER"
          
          # Run the database update command with SQL Server authentication
          dotnet "$DATABASE_DLL" update "$DATABASE_SERVER" "$DATABASE_NAME" "$SCRIPTS_DIR" "$DATABASE_USER" "$DATABASE_PASSWORD"
          
          if [ $? -ne 0 ]; then
            echo "Error: Database migration failed"
            exit 1
          fi
          
          echo "✓ Database migrations completed successfully"
          
          # Clean up
          rm -rf ./database-extract ./packages

      - name: Deploy existing release to Production
        uses: OctopusDeploy/create-release-action@v1
        with:
          api_key: ${{ secrets.OCTO_API_KEY }}
          server: ${{ secrets.OCTOPUS_URL }}
          space: ${{ vars.OCTOPUS_SPACE }}
          project: ${{ vars.OCTOPUS_PROJECT }}
          release_number: ${{ env.BUILD_BUILDNUMBER }}
          deploy_to: "Prod"
          progress: true
          deployment_timeout: 00:30:00
          # Note: This will deploy the existing release that was created during TDD deployment          