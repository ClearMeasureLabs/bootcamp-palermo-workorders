name: Integration Build

on:
  push:
    branches: ['*']
  pull_request:
    branches: ['*']
  workflow_dispatch:
    inputs:
      deploy_to_uat:
        description: 'Deploy to UAT environment'
        required: false
        default: false
        type: boolean
      deploy_to_prod:
        description: 'Deploy to Production environment'
        required: false
        default: false
        type: boolean

env:
  MAJOR_VERSION: 1
  MINOR_VERSION: 3
  RELEASE_VERSION: 588

jobs:

  deploy-to-tdd:
    name: TDD
    runs-on: windows-latest
    environment:
      name: TDD
    
    steps:
      - uses: actions/checkout@v6
      - uses: actions/setup-node@v6
      - name: Setup .NET SDK 10.0.100
        uses: actions/setup-dotnet@v5
        with:
          dotnet-version: '10.0.100'
      
      - name: Set Version
        shell: pwsh
        run: |
          $version = "${{ env.MAJOR_VERSION }}.${{ env.MINOR_VERSION }}.${{ env.RELEASE_VERSION}}"
          "BUILD_BUILDNUMBER=$version" >> $env:GITHUB_ENV
          "VERSION=$version" >> $env:GITHUB_ENV
          Write-Host "Build version: $version"



      - name: Login to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
  
      - name: Get Container App FQDN and Connection String
        shell: pwsh
        run: |
          $containerAppFqdn = az containerapp show `
            --name ui-gh `
            --resource-group bootcamp-tdd `
            --query properties.configuration.ingress.fqdn `
            -o tsv
          
          if ([string]::IsNullOrWhiteSpace($containerAppFqdn)) {
            Write-Error "Error: Could not retrieve container app FQDN"
            exit 1
          }
          
          $containerAppUrl = "https://$containerAppFqdn"
          Write-Host "Container App FQDN: $containerAppFqdn"
          Write-Host "Container App URL: $containerAppUrl"
          "CONTAINER_APP_URL=$containerAppUrl" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
          "ApplicationBaseUrl=$containerAppUrl" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
          
          # Get the connection string from container app environment variables
          $containerAppConnectionString = az containerapp show `
            --name ui-gh `
            --resource-group bootcamp-tdd `
            --query "properties.template.containers[0].env[?name=='ConnectionStrings__SqlConnectionString'].value" `
            -o tsv
          Write-Host "Container App Connection String retrieved: $([string]::IsNullOrWhiteSpace($containerAppConnectionString))"
          "ConnectionStrings__SqlConnectionString=$containerAppConnectionString" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
          "CONTAINER_APP_CONNECTION_STRING=$containerAppConnectionString" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
      - name: Download Acceptance Tests Package
        uses: actions/download-artifact@v4
        with:
          name: churchbulletin-nuget-packages
          path: ./packages  
      - name: Extract and Configure Acceptance Tests
        if: success()
        shell: pwsh
        run: |
          Write-Host "Extracting package..."
          Expand-Archive -Path "./packages/ChurchBulletin.AcceptanceTests.${{ env.BUILD_BUILDNUMBER }}.nupkg" -DestinationPath "./acceptance-tests-package" -Force

          # Find the test DLL - NuGet packages may extract to different structures
          $testDll = Get-ChildItem -Path ./acceptance-tests-package -Recurse -Filter "*AcceptanceTests*.dll" | 
            Where-Object { $_.Name -notlike "*TestAdapter*" -and $_.Name -notlike "*TestHost*" } | 
            Select-Object -First 1

          if (-not $testDll) {
            Write-Warning "Test DLL not found. Listing all DLLs:"
            Get-ChildItem -Path ./acceptance-tests-package -Recurse -Filter "*.dll" | Select-Object FullName
            Write-Error "Could not find AcceptanceTests DLL in extracted package"
            exit 1
          }

          Write-Host "Found test DLL: $($testDll.FullName)"
      - name: Install Playwright browsers and driver
        shell: pwsh
        run: |
          Write-Host "Installing Playwright via npm..."
          
          # Install Playwright via npm (doesn't require project context)
          npm install -g playwright@1.54.0
          if ($LASTEXITCODE -ne 0) {
            Write-Error "Failed to install Playwright npm package"
            exit $LASTEXITCODE
          }
          
          # Install browsers and system dependencies
          Write-Host "Installing Playwright browsers and system dependencies..."
          playwright install --with-deps
          if ($LASTEXITCODE -ne 0) {
            Write-Error "Failed to install Playwright browsers and driver"
            exit $LASTEXITCODE
          }
          
          # The .NET Playwright package expects browsers in .playwright in workspace root
          # npm installs to LOCALAPPDATA\ms-playwright, so we need to set the path
          $expectedBrowsersPath = Join-Path $env:GITHUB_WORKSPACE ".playwright"
          $npmBrowsersPath = Join-Path $env:LOCALAPPDATA "ms-playwright"
          
          Write-Host "Copying browsers from npm location to expected location..."
          if (Test-Path $expectedBrowsersPath) {
            Remove-Item -Path $expectedBrowsersPath -Recurse -Force -ErrorAction SilentlyContinue
          }
          
          robocopy "$npmBrowsersPath" "$expectedBrowsersPath" /E /NFL /NDL /NJH /NJS 2>&1 | Out-Null
          if ($LASTEXITCODE -ge 8) {
            Copy-Item -Path $npmBrowsersPath -Destination $expectedBrowsersPath -Recurse -Force
          }
          
          # Set environment variable for .NET Playwright to find browsers
          $env:PLAYWRIGHT_BROWSERS_PATH = $expectedBrowsersPath
          "PLAYWRIGHT_BROWSERS_PATH=$expectedBrowsersPath" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
          
          Write-Host "Playwright browsers and driver installed successfully"

      # - name: Run acceptance tests
      #   shell: pwsh
      #   env:
      #     ApplicationBaseUrl: ${{ env.CONTAINER_APP_URL }}
      #     ConnectionStrings__SqlConnectionString: ${{ env.CONTAINER_APP_CONNECTION_STRING }}
      #     StartLocalServer: "false"
      #   run: |
      #     Write-Host "Running acceptance tests..."
      #     Write-Host "ApplicationBaseUrl: $env:ApplicationBaseUrl"
      #     Write-Host "ConnectionStrings__SqlConnectionString: $([string]::IsNullOrWhiteSpace($env:ConnectionStrings__SqlConnectionString))"
      #     Write-Host "StartLocalServer: $env:StartLocalServer"
          
      #     # Find the test DLL
      #     $testDll = Get-ChildItem -Path ./acceptance-tests-package -Recurse -Filter "*AcceptanceTests*.dll" | 
      #       Where-Object { $_.Name -notlike "*TestAdapter*" -and $_.Name -notlike "*TestHost*" } | 
      #       Select-Object -First 1
          
      #     if (-not $testDll) {
      #       Write-Error "Test DLL not found in acceptance-tests-package"
      #       exit 1
      #     }

      #     dotnet test $($testDll.FullName) `
      #       /Logger:trx;LogFileName=AcceptanceTests-TDD.trx `
      #       /ResultsDirectory:./TestResults `
      #       /Parallel
      #     if ($LASTEXITCODE -ne 0) {
      #       Write-Error "Failed to run acceptance tests"
      #       exit $LASTEXITCODE
      #     }
      #     Write-Host "Acceptance tests completed successfully"

      # - name: Run acceptance tests the hard way
      #   id: run-acceptance-tests-the-hard-way
      #   shell: pwsh
      #   if: false
      #   env:
      #     ApplicationBaseUrl: ${{ env.CONTAINER_APP_URL }}
      #     ConnectionStrings__SqlConnectionString: ${{ env.CONTAINER_APP_CONNECTION_STRING }}
      #     StartLocalServer: "false"
      #     PLAYWRIGHT_BROWSERS_PATH: ${{ env.PLAYWRIGHT_BROWSERS_PATH }}
      #   run: |
      #     Write-Host "Installing Playwright browsers and driver..."
          
      #     # The .NET Playwright package looks for browsers in .playwright directory in the workspace root
      #     $expectedBrowsersPath = Join-Path $env:GITHUB_WORKSPACE ".playwright"
      #     Write-Host "Expected browsers path: $expectedBrowsersPath"
          
      #     # Step 1: Install browsers via npm (this works reliably)
      #     Write-Host "Step 1: Installing Playwright browsers via npm..."
      #     npm install -g playwright@1.54.0
          
      #     if ($LASTEXITCODE -ne 0) {
      #       Write-Error "Failed to install Playwright npm package"
      #       exit $LASTEXITCODE
      #     }
          
      #     playwright install --with-deps
          
      #     if ($LASTEXITCODE -ne 0) {
      #       Write-Error "Failed to install Playwright browsers"
      #       exit $LASTEXITCODE
      #     }
          
      #     # Step 2: Copy browsers from npm location to expected location
      #     $npmBrowsersPath = Join-Path $env:LOCALAPPDATA "ms-playwright"
      #     Write-Host "Step 2: Copying browsers from npm location to expected location..."
          
      #     if (Test-Path $expectedBrowsersPath) {
      #       Remove-Item -Path $expectedBrowsersPath -Recurse -Force -ErrorAction SilentlyContinue
      #     }
          
      #     robocopy "$npmBrowsersPath" "$expectedBrowsersPath" /E /NFL /NDL /NJH /NJS 2>&1 | Out-Null
      #     if ($LASTEXITCODE -ge 8) {
      #       Copy-Item -Path $npmBrowsersPath -Destination $expectedBrowsersPath -Recurse -Force
      #     }
          
      #     Write-Host "✓ Browsers copied to expected location"
          
      #     # Step 3: Install the Node.js driver that .NET Playwright needs
      #     # The driver is typically embedded in the Microsoft.Playwright package
      #     # We need to extract it or download it
      #     Write-Host "Step 3: Installing Playwright Node.js driver..."
          
      #     $driverPath = Join-Path $expectedBrowsersPath "node" "win32_x64"
      #     $nodeExe = Join-Path $driverPath "node.exe"
          
      #     # Create the directory structure
      #     New-Item -ItemType Directory -Path $driverPath -Force | Out-Null
          
      #     # Try to use dotnet to run the Playwright install command
      #     # Find the Microsoft.Playwright.dll
      #     $playwrightDll = Get-ChildItem -Path ./acceptance-tests-package -Recurse -Filter "Microsoft.Playwright.dll" | Select-Object -First 1
          
      #     if ($playwrightDll) {
      #       Write-Host "Found Microsoft.Playwright.dll: $($playwrightDll.FullName)"
      #       $dllDir = Split-Path -Parent $playwrightDll.FullName
            
      #       # Try to use the DLL to install the driver
      #       # The .NET Playwright package has a method to install the driver
      #       Push-Location $dllDir
      #       try {
      #         # Try using dotnet exec with the DLL to install driver
      #         # This might work if the DLL has the install functionality
      #         Write-Host "Attempting to install driver using Microsoft.Playwright.dll..."
              
      #         # The driver URL is typically: https://playwright.azureedge.net/builds/driver/...
      #         # But we need the exact version. Let's try downloading from the known location
      #         $playwrightVersion = "1.54.0"
      #         $driverUrl = "https://playwright.azureedge.net/builds/driver/playwright-${playwrightVersion}-win32_x64.zip"
              
      #         Write-Host "Downloading driver from: $driverUrl"
      #         $driverZip = Join-Path $env:TEMP "playwright-driver.zip"
              
      #         try {
      #           Invoke-WebRequest -Uri $driverUrl -OutFile $driverZip -UseBasicParsing -ErrorAction Stop
                
      #           Write-Host "Extracting driver..."
      #           $tempExtract = Join-Path $env:TEMP "playwright-driver-extract"
      #           if (Test-Path $tempExtract) {
      #             Remove-Item -Path $tempExtract -Recurse -Force
      #           }
      #           Expand-Archive -Path $driverZip -DestinationPath $tempExtract -Force
                
      #           # Find node.exe in the extracted files
      #           $extractedNode = Get-ChildItem -Path $tempExtract -Recurse -Filter "node.exe" | Select-Object -First 1
      #           if ($extractedNode) {
      #             Copy-Item -Path $extractedNode.FullName -Destination $nodeExe -Force
      #             Write-Host "✓ Driver installed successfully"
      #           } else {
      #             Write-Warning "node.exe not found in extracted driver zip"
      #           }
                
      #           # Cleanup
      #           Remove-Item -Path $tempExtract -Recurse -Force -ErrorAction SilentlyContinue
      #           Remove-Item -Path $driverZip -Force -ErrorAction SilentlyContinue
      #         } catch {
      #           Write-Warning "Failed to download driver: $_"
      #           Write-Host "Driver installation will be skipped - tests may fail"
      #         }
      #       } finally {
      #         Pop-Location
      #       }
      #     } else {
      #       Write-Warning "Microsoft.Playwright.dll not found - cannot install driver"
      #     }
          
      #     # Verify installation
      #     Write-Host "Verifying installation..."
      #     if (Test-Path $nodeExe) {
      #       Write-Host "✓ Playwright driver (node.exe) found at: $nodeExe"
      #     } else {
      #       Write-Error "Failed to install Playwright driver. node.exe not found at: $nodeExe"
      #       Write-Host "Driver directory contents:"
      #       if (Test-Path $driverPath) {
      #         Get-ChildItem -Path $driverPath -Recurse | Select-Object FullName
      #       }
      #       exit 1
      #     }
          
      #     # Set environment variable
      #     $env:PLAYWRIGHT_BROWSERS_PATH = $expectedBrowsersPath
      #     "PLAYWRIGHT_BROWSERS_PATH=$expectedBrowsersPath" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8

      #     ###########################
      #     Write-Host "Running Acceptance Tests"
          
      #     # Find VSTest - try common locations
      #     $vsTestPaths = @(
      #       "C:\Program Files\Microsoft Visual Studio\2022\Enterprise\Common7\IDE\CommonExtensions\Microsoft\TestWindow\vstest.console.exe",
      #       "C:\Program Files\Microsoft Visual Studio\2022\Professional\Common7\IDE\CommonExtensions\Microsoft\TestWindow\vstest.console.exe",
      #       "C:\Program Files\Microsoft Visual Studio\2022\Community\Common7\IDE\CommonExtensions\Microsoft\TestWindow\vstest.console.exe",
      #       "C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\Common7\IDE\CommonExtensions\Microsoft\TestWindow\vstest.console.exe"
      #     )
          
      #     $vsTestPath = $null
      #     foreach ($path in $vsTestPaths) {
      #       if (Test-Path $path) {
      #         $vsTestPath = $path
      #         Write-Host "Found VSTest at: $vsTestPath"
      #         break
      #       }
      #     }
          
      #     if (-not $vsTestPath) {
      #       Write-Error "VSTest not found in any expected location"
      #       exit 1
      #     }
          
      #     # Find the test DLL
      #     $testDll = Get-ChildItem -Path ./acceptance-tests-package -Recurse -Filter "*AcceptanceTests*.dll" | 
      #       Where-Object { $_.Name -notlike "*TestAdapter*" -and $_.Name -notlike "*TestHost*" } | 
      #       Select-Object -First 1
          
      #     if (-not $testDll) {
      #       Write-Error "Test DLL not found in acceptance-tests-package"
      #       exit 1
      #     }
          
      #     Write-Host "Found test DLL: $($testDll.FullName)"
          
      #     # Create results directory
      #     $resultsDir = Join-Path $PWD "TestResults"
      #     New-Item -ItemType Directory -Path $resultsDir -Force | Out-Null
          
      #     # Find runsettings file if it exists
      #     $runSettingsFile = Get-ChildItem -Path ./acceptance-tests-package -Recurse -Filter "*.runsettings" | Select-Object -First 1
          
      #     # Build VSTest command arguments
      #     # Don't quote paths in the array - PowerShell will handle quoting automatically
      #     $vstestArgs = @(
      #       $testDll.FullName,
      #       "/Logger:trx;LogFileName=AcceptanceTests.trx",
      #       "/ResultsDirectory:$resultsDir",
      #       "/Parallel"
      #     )
          
      #     # if ($runSettingsFile) {
      #     #   $vstestArgs += "/Settings:$($runSettingsFile.FullName)"
      #     #   Write-Host "Using runsettings: $($runSettingsFile.FullName)"
      #     # }
          
      #     Write-Host "Running VSTest command:"
      #     Write-Host "  Executable: $vsTestPath"
      #     Write-Host "  Arguments: $($vstestArgs -join ' ')"
          
      #     # Execute VSTest - PowerShell will automatically quote paths with spaces
      #     & "$vsTestPath" $vstestArgs
          
      #     if ($LASTEXITCODE -ne 0) {
      #       Write-Error "VSTest failed with exit code: $LASTEXITCODE"
      #       exit $LASTEXITCODE
      #     }          

      - name: Run acceptance tests
        uses: josepho0918/vstest-action@main
        env:
          ApplicationBaseUrl: ${{ env.CONTAINER_APP_URL }}
          ConnectionStrings__SqlConnectionString: ${{ env.CONTAINER_APP_CONNECTION_STRING }}
          StartLocalServer: "false"
          PLAYWRIGHT_BROWSERS_PATH: ${{ env.PLAYWRIGHT_BROWSERS_PATH }}
        with:
          testAssembly: |
            **\*AcceptanceTests.dll
            !**\*TestAdapter.dll
            !**\obj\**
          searchFolder: ./acceptance-tests-package/
          runInParallel: true

      - name: Upload Acceptance Test Results
        uses: actions/upload-artifact@v4
        if: success()
        with:
          name: acceptance-test-results-tdd
          path: TestResults/**/*.trx
          retention-days: 30 


  deploy-to-uat:
    name: UAT
    needs: [deploy-to-tdd]
    if: success() 
    runs-on: ubuntu-latest
    environment:
      name: UAT
    
    steps:
      - uses: actions/checkout@v4
      - name: Set Version
        run: |
          version="${{ env.MAJOR_VERSION }}.${{ env.MINOR_VERSION }}.${{ github.run_number }}"
          echo "BUILD_BUILDNUMBER=$version" >> $GITHUB_ENV
          echo "VERSION=$version" >> $GITHUB_ENV
          echo "Build version: $version"

      - name: Deploy Octopus Release to UAT
        uses: OctopusDeploy/deploy-release-action@v3
        id: start-deploy-to-uat
        env:
          OCTOPUS_API_KEY: ${{ secrets.OCTO_API_KEY }}
          OCTOPUS_URL: ${{ secrets.OCTOPUS_URL }}
          OCTOPUS_SPACE: ${{ vars.OCTOPUS_SPACE }}
        with:
          project: ${{ vars.OCTOPUS_PROJECT }}   
          release_number: ${{ env.BUILD_BUILDNUMBER }}
          environments: "UAT"

      - name: Wait for the UAT deployment to complete
        uses: OctopusDeploy/await-task-action@v3
        env:
          OCTOPUS_API_KEY: ${{ secrets.OCTO_API_KEY  }}
          OCTOPUS_URL: ${{ secrets.OCTOPUS_URL }}
          OCTOPUS_SPACE: ${{ vars.OCTOPUS_SPACE }}
        with:
          server_task_id: ${{ fromJson(steps.start-deploy-to-uat.outputs.server_tasks)[0].serverTaskId }}
          timeout_after: 1800          
          
  deploy-to-prod:
    name: Prod
    needs: [deploy-to-uat]
    if: success() 
    runs-on: ubuntu-latest
    environment:
      name: Prod
    
    steps:
      - uses: actions/checkout@v4
      - name: Set Version
        run: |
          version="${{ env.MAJOR_VERSION }}.${{ env.MINOR_VERSION }}.${{ github.run_number }}"
          echo "BUILD_BUILDNUMBER=$version" >> $GITHUB_ENV
          echo "VERSION=$version" >> $GITHUB_ENV
          echo "Build version: $version"

      - name: Deploy Octopus Release to Prod
        uses: OctopusDeploy/deploy-release-action@v3
        id: start-deploy-to-prod
        env:
          OCTOPUS_API_KEY: ${{ secrets.OCTO_API_KEY }}
          OCTOPUS_URL: ${{ secrets.OCTOPUS_URL }}
          OCTOPUS_SPACE: ${{ vars.OCTOPUS_SPACE }}
        with:
          project: ${{ vars.OCTOPUS_PROJECT }}   
          release_number: ${{ env.BUILD_BUILDNUMBER }}
          environments: "Prod"

      - name: Wait for the Prod deployment to complete
        uses: OctopusDeploy/await-task-action@v3
        env:
          OCTOPUS_API_KEY: ${{ secrets.OCTO_API_KEY  }}
          OCTOPUS_URL: ${{ secrets.OCTOPUS_URL }}
          OCTOPUS_SPACE: ${{ vars.OCTOPUS_SPACE }}
        with:
          server_task_id: ${{ fromJson(steps.start-deploy-to-prod.outputs.server_tasks)[0].serverTaskId }}
          timeout_after: 1800          
