name: Build
run-name: "1.4.${{ github.run_number }} • Build • ${{ github.event.pull_request.title != '' && github.event.pull_request.title || github.head_ref || github.ref_name }}"
on:
  push:
  workflow_dispatch:
env:
  MAJOR_VERSION: 1
  MINOR_VERSION: 4

jobs:
  build-linux:
    name: Integration Build (SQL container)
    runs-on: ubuntu-latest
    concurrency:
      # Integration Build will be cancelled when new commits arrive on the branch. 
      # To protect the master branch, use ${{ github.ref != 'refs/heads/main' }} for cancel-in-progress:
      group: build-${{ github.ref }}
      cancel-in-progress: true
    permissions:
      contents: read
      packages: write
      pull-requests: write
    env:
      BUILD_CONFIGURATION: Release
      DOTNET_ROLL_FORWARD: LatestMajor

    steps:
      # Checkout code
      - name: Checkout code
        uses: actions/checkout@v6.0.1

      # Set version environment variable
      - name: Set Version
        run: |
          version="${{ env.MAJOR_VERSION }}.${{ env.MINOR_VERSION }}.${{ github.run_number }}"
          echo "BUILD_BUILDNUMBER=$version" >> $GITHUB_ENV
          echo "VERSION=$version" >> $GITHUB_ENV
          echo "$version" > build_version.txt
          echo "Build version: $version"
          echo "github.ref=${{ github.ref }}"

      - name: Run CI Build 
        shell: pwsh
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          BUILD_BUILDNUMBER: ${{ env.VERSION }}
        run: |
          Write-Host "Running CI Build"
          . ./build.ps1
          Invoke-CIBuild

      # Publish test results
      - name: Test Reporter
        uses: dorny/test-reporter@v2.1.1
        if: always()
        with:
          name: Linux CI Test Results
          path: 'build/test/**/*.trx'
          reporter: dotnet-trx

      # Publish code coverage
      - name: Publish Code Coverage
        uses: codecov/codecov-action@v4
        if: always()
        with:
          files: '**/build/test/**/In/**/coverage.cobertura.xml'
          flags: unittests-linux
          name: codecov-linux

      # Upload test results as artifacts
      - name: Upload Test Results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results-linux
          path: build/test/**/*.trx
          retention-days: 2

      # Upload code coverage as artifacts
      - name: Upload Code Coverage
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: code-coverage-linux
          path: '**/build/test/**/In/**/coverage.cobertura.xml'
          retention-days: 2

      # Package Everything as NuGet Packages
      - name: Create NuGet Packages
        shell: pwsh
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          BUILD_BUILDNUMBER: ${{ env.VERSION }}
        run: |
          . ./build.ps1
          Package-Everything

      # Upload packages as artifacts
      - name: Upload NuGet Package artifacts
        uses: actions/upload-artifact@v4
        if: success()
        with:
          name: churchbulletin-nuget-packages
          path: build/*.nupkg
          retention-days: 2

      - name: Upload build_version.txt artifact
        uses: actions/upload-artifact@v4
        if: success()
        with:
          name: build-version
          path: build_version.txt
          retention-days: 2

      - name: Mark PR as ready for review
        if: success()
        env:
          GH_TOKEN: ${{ secrets.COPILOT_PAT }}
        run: |
          # Find PR associated with this branch
          BRANCH_NAME="${GITHUB_REF#refs/heads/}"
          echo "Looking for PR from branch: $BRANCH_NAME"

          PR_NUMBER=$(gh pr list --head "$BRANCH_NAME" --state open --json number --jq '.[0].number' 2>/dev/null || echo "")

          if [ -n "$PR_NUMBER" ]; then
            echo "Found PR #$PR_NUMBER, marking as ready for review..."
            gh pr ready "$PR_NUMBER" || echo "PR may already be ready or unable to mark ready"
          else
            echo "No open PR found for branch $BRANCH_NAME"
          fi

  build-sqlite:
    name: Integration Build (SQLite)
    runs-on: ubuntu-latest
    concurrency:
      group: build-sqlite-${{ github.ref }}
      cancel-in-progress: true
    permissions:
      contents: read
      packages: read
    env:
      BUILD_CONFIGURATION: Release
      DATABASE_ENGINE: SQLite

    steps:
      - name: Checkout code
        uses: actions/checkout@v6.0.1

      - name: Set Version
        run: |
          version="${{ env.MAJOR_VERSION }}.${{ env.MINOR_VERSION }}.${{ github.run_number }}"
          echo "BUILD_BUILDNUMBER=$version" >> $GITHUB_ENV

      - name: Run Private Build (SQLite)
        shell: pwsh
        env:
          BUILD_BUILDNUMBER: ${{ env.BUILD_BUILDNUMBER }}
        run: |
          Write-Host "Running Private Build with SQLite"
          . ./build.ps1
          Invoke-PrivateBuild -UseSqlite

      - name: Test Reporter
        uses: dorny/test-reporter@v2.1.1
        if: always()
        with:
          name: SQLite Test Results
          path: 'build/test/**/*.trx'
          reporter: dotnet-trx

      - name: Upload Test Results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results-sqlite
          path: build/test/**/*.trx
          retention-days: 2

  integration-build-arm:
    name: Integration Build (ARM SQLite)
    runs-on: ubuntu-24.04-arm
    concurrency:
      group: build-arm-${{ github.ref }}
      cancel-in-progress: true
    permissions:
      contents: read
      packages: read
    env:
      BUILD_CONFIGURATION: Release
      DATABASE_ENGINE: SQLite

    steps:
      - name: Checkout code
        uses: actions/checkout@v6.0.1

      - name: Set Version
        run: |
          version="${{ env.MAJOR_VERSION }}.${{ env.MINOR_VERSION }}.${{ github.run_number }}"
          echo "BUILD_BUILDNUMBER=$version" >> $GITHUB_ENV

      - name: Run Private Build (ARM SQLite)
        shell: pwsh
        env:
          BUILD_BUILDNUMBER: ${{ env.BUILD_BUILDNUMBER }}
        run: |
          Write-Host "Running Private Build with SQLite on ARM"
          . ./build.ps1
          Invoke-PrivateBuild -UseSqlite

      - name: Test Reporter
        uses: dorny/test-reporter@v2.1.1
        if: always()
        with:
          name: ARM SQLite Test Results
          path: 'build/test/**/*.trx'
          reporter: dotnet-trx

      - name: Upload Test Results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results-arm-sqlite
          path: build/test/**/*.trx
          retention-days: 2

  code-analysis:
    name: Code Analysis
    runs-on: ubuntu-latest
    concurrency:
      group: code-analysis-${{ github.ref }}
      cancel-in-progress: true
    permissions:
      contents: read
      packages: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v6.0.1

      - name: Restore solution
        run: dotnet restore src/ChurchBulletin.sln

      - name: Check code style
        run: dotnet format style src/ChurchBulletin.sln --verify-no-changes --verbosity normal

      - name: Check analyzers
        run: dotnet format analyzers src/ChurchBulletin.sln --verify-no-changes --verbosity normal

      - name: Build with code analysis
        run: |
          dotnet build src/ChurchBulletin.sln --configuration Release --no-restore \
            /p:TreatWarningsAsErrors=true \
            /p:EnforceCodeStyleInBuild=true

  build-windows:
    name: Integration Build (Windows LocalDB)
    runs-on: windows-latest
    concurrency:
      group: build-windows-${{ github.ref }}
      cancel-in-progress: true
    permissions:
      contents: read
      packages: read
    env:
      BUILD_CONFIGURATION: Release

    steps:
      - name: Checkout code
        uses: actions/checkout@v6.0.1

      - name: Set Version
        shell: pwsh
        run: |
          $version = "${{ env.MAJOR_VERSION }}.${{ env.MINOR_VERSION }}.${{ github.run_number }}"
          "BUILD_BUILDNUMBER=$version" >> $env:GITHUB_ENV

      - name: Run Private Build (Windows LocalDB)
        shell: pwsh
        env:
          BUILD_BUILDNUMBER: ${{ env.BUILD_BUILDNUMBER }}
        run: |
          Write-Host "Running Private Build with Windows LocalDB"
          . ./build.ps1
          Invoke-PrivateBuild

      - name: Test Reporter
        uses: dorny/test-reporter@v2.1.1
        if: always()
        with:
          name: Windows LocalDB Test Results
          path: 'build/test/**/*.trx'
          reporter: dotnet-trx

      - name: Upload Test Results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results-windows
          path: build/test/**/*.trx
          retention-days: 2

  docker-build-image-for-churchbulletin-ui:
    name: Publish Release Candidate
    needs: [build-linux, build-sqlite, integration-build-arm, code-analysis, build-windows]
    if: success() 
    runs-on: ubuntu-latest
    concurrency:
      # Stop publishing a release candidate if a newer job arrives.
      # To protect the master branch, use ${{ github.ref != 'refs/heads/main' }} for cancel-in-progress:
      group: build-${{ github.ref }}
      cancel-in-progress: true
    permissions:
      contents: read
      packages: read
    
    steps:
      # Checkout code
      - name: Checkout code
        uses: actions/checkout@v6.0.1

      # Set version environment variable (same as build-linux job)
      - name: Set Version
        run: |
          version="${{ env.MAJOR_VERSION }}.${{ env.MINOR_VERSION }}.${{ github.run_number }}"
          echo "BUILD_BUILDNUMBER=$version" >> $GITHUB_ENV
          echo "VERSION=$version" >> $GITHUB_ENV
          echo "Build version: $version"

      # Download NuGet packages from build-linux job
      - name: Download NuGet Packages
        uses: actions/download-artifact@v4
        with:
          name: churchbulletin-nuget-packages
          path: ./packages

      # Extract ChurchBulletin.UI NuGet package
      - name: Extract UI NuGet Package
        run: |
          # Find the ChurchBulletin.UI package
          PACKAGE_FILE=$(find ./packages -name "ChurchBulletin.UI.*.nupkg" | head -n 1)
          
          if [ -z "$PACKAGE_FILE" ]; then
            echo "Error: ChurchBulletin.UI package not found"
            ls -la ./packages/
            exit 1
          fi
          
          echo "Found package: $PACKAGE_FILE"
          
          # Create temporary extraction directory
          mkdir -p ./package-extract
          
          # Extract the Octopus package (it's a ZIP file)
          # Use -o to overwrite without prompting
          unzip -o "$PACKAGE_FILE" -d ./package-extract
          
          # Fix permissions on extracted files before copying
          # First, ensure directories are accessible
          find ./package-extract -type d -exec chmod u+rwx {} \;
          # Then ensure files are readable
          find ./package-extract -type f -exec chmod u+r {} \;
          
          # Create built directory (where Dockerfile expects files)
          mkdir -p ./built
          
          # Octopus packages may have files directly in root or nested
          # Look for the DLL file to determine structure
          DLL_PATH=$(find ./package-extract -name "ClearMeasure.Bootcamp.UI.Server.dll" 2>/dev/null | head -n 1)
          
          if [ -z "$DLL_PATH" ]; then
            echo "Error: ClearMeasure.Bootcamp.UI.Server.dll not found in package"
            echo "Package contents:"
            find ./package-extract -type f 2>/dev/null | head -20
            exit 1
          fi
          
          # Get the directory containing the DLL
          DLL_DIR=$(dirname "$DLL_PATH")
          
          # Copy all contents from the DLL's directory to built using tar
          # tar handles permissions and file types (files/directories/symlinks) correctly
          (cd "$DLL_DIR" && tar cf - .) | (cd ./built && tar xf -)
          
          # Remove any package metadata files that might have been copied
          find ./built -name "*.nuspec" -delete 2>/dev/null || true
          find ./built -name "[Content_Types].xml" -delete 2>/dev/null || true
          find ./built -name "*.psmdcp" -delete 2>/dev/null || true
          find ./built -name "_rels" -type d -exec rm -rf {} + 2>/dev/null || true
          find ./built -path "*/package/services/metadata/*" -delete 2>/dev/null || true
          
          # Verify extracted files
          echo "Extracted files in built directory:"
          ls -la built/ | head -20
          
          # Verify we have the expected DLL
          if [ -f ./built/ClearMeasure.Bootcamp.UI.Server.dll ]; then
            echo "✓ Successfully extracted UI Server package"
          else
            echo "Error: ClearMeasure.Bootcamp.UI.Server.dll not found after extraction"
            exit 1
          fi
          
          # Clean up
          rm -rf ./package-extract ./packages

      # Login to Azure (before Docker build to enable layer caching)
      - name: Login to Azure
        uses: azure/login@v2
        with:
          # TODO:  Need to create the AZURE_CREDENTIALS secret in the GitHub repository.
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      # Login to Azure Container Registry (before Docker build for caching)
      - name: Login to ACR
        run: |
          az acr login --name churchbulletingithubacr

      # Build Docker image with BuildKit cache
      - name: Build Docker image
        run: |
          IMAGE_TAG="${{ env.BUILD_BUILDNUMBER }}"
          # Enable BuildKit for better caching
          export DOCKER_BUILDKIT=1
          # Pull latest image for layer caching
          docker pull churchbulletingithubacr.azurecr.io/churchbulletin.ui:latest || true
          # Build with cache from latest image
          docker build \
            --cache-from churchbulletingithubacr.azurecr.io/churchbulletin.ui:latest \
            -f Dockerfile \
            -t churchbulletingithubacr.azurecr.io/churchbulletin.ui:${IMAGE_TAG} \
            -t churchbulletingithubacr.azurecr.io/churchbulletin.ui:latest .

      # Push Docker image to ACR
      - name: Push Docker image to ACR
        run: |
          IMAGE_TAG="${{ env.BUILD_BUILDNUMBER }}"
          docker push churchbulletingithubacr.azurecr.io/churchbulletin.ui:${IMAGE_TAG}
          docker push churchbulletingithubacr.azurecr.io/churchbulletin.ui:latest

  publish-github-packages:
    name: Publish to GitHub Packages
    needs: [build-linux]
    if: success()
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - name: Download NuGet Packages
        uses: actions/download-artifact@v4
        with:
          name: churchbulletin-nuget-packages
          path: ./packages

      - name: Publish nupkgs to GitHub Packages
        env:
          NUGET_AUTH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          OWNER="${{ github.repository_owner }}"
          FEED_URL="https://nuget.pkg.github.com/$OWNER/index.json"

          echo "Publishing packages to GitHub Packages..."
          for package in packages/*.nupkg; do
            if [ -f "$package" ]; then
              echo "Publishing $package..."
              dotnet nuget push "$package" \
                --source "$FEED_URL" \
                --api-key "$NUGET_AUTH_TOKEN" \
                --timeout 600 \
                --skip-duplicate || echo "Warning: Failed to publish $package (may already exist)"
            fi
          done

  publish-octopus:
    name: Publish to Octopus Deploy
    needs: [build-linux]
    if: success()
    runs-on: ubuntu-latest
    permissions:
      contents: read
    env:
      DOTNET_ROLL_FORWARD: LatestMajor
    steps:
      - name: Download NuGet Packages
        uses: actions/download-artifact@v4
        with:
          name: churchbulletin-nuget-packages
          path: ./packages

      - name: Publish Packages to Octopus Deploy
        shell: pwsh
        env:
          OCTOPUS_URL: ${{ secrets.OCTOPUS_URL }}
          OCTOPUS_API_KEY: ${{ secrets.OCTO_API_KEY }}
          OCTOPUS_SPACE: ${{ vars.OCTOPUS_SPACE }}
          BUILD_BUILDNUMBER: "${{ env.MAJOR_VERSION }}.${{ env.MINOR_VERSION }}.${{ github.run_number }}"
        run: |
          $ErrorActionPreference = "Stop"

          if ([string]::IsNullOrWhiteSpace($env:OCTOPUS_URL)) {
            Write-Warning "OCTOPUS_URL not set. Skipping Octopus package publishing."
            exit 0
          }
          if ([string]::IsNullOrWhiteSpace($env:OCTOPUS_API_KEY)) {
            Write-Warning "OCTOPUS_API_KEY not set. Skipping Octopus package publishing."
            exit 0
          }

          dotnet tool install --global Octopus.DotNet.Cli 2>&1 | Out-Null
          $dotnetToolsPath = [System.IO.Path]::Combine(
            [System.Environment]::GetFolderPath([System.Environment+SpecialFolder]::UserProfile),
            ".dotnet", "tools")
          if ($env:PATH -notlike "*$dotnetToolsPath*") {
            $env:PATH = "$dotnetToolsPath$([System.IO.Path]::PathSeparator)$env:PATH"
          }

          $packageFiles = Get-ChildItem -Path "./packages" -Filter "*.nupkg"
          if (-not $packageFiles -or $packageFiles.Count -eq 0) {
            Write-Warning "No packages found"
            exit 0
          }

          Write-Host "Publishing $($packageFiles.Count) package(s) to Octopus Deploy..."
          $failed = 0
          foreach ($pkg in $packageFiles) {
            $pushArgs = @("push", "--package", $pkg.FullName, "--server", $env:OCTOPUS_URL, "--apiKey", $env:OCTOPUS_API_KEY)
            if (-not [string]::IsNullOrWhiteSpace($env:OCTOPUS_SPACE)) {
              $pushArgs += "--space"
              $pushArgs += $env:OCTOPUS_SPACE
            }
            & dotnet-octo $pushArgs
            if ($LASTEXITCODE -ne 0) { $failed++ }
          }
          if ($failed -gt 0) {
            Write-Warning "$failed package(s) failed to publish to Octopus Deploy."
          }

  acceptance-tests:
    name: Acceptance Tests
    needs: [docker-build-image-for-churchbulletin-ui]
    if: success()
    runs-on: ubuntu-latest
    concurrency:
      group: acceptance-tests-${{ github.ref }}
      cancel-in-progress: true
    permissions:
      contents: read
      packages: read
    env:
      BUILD_CONFIGURATION: Release

    steps:
      - name: Checkout code
        uses: actions/checkout@v6.0.1

      - name: Cache NuGet packages
        uses: actions/cache@v4
        with:
          path: ~/.nuget/packages
          key: nuget-${{ runner.os }}-${{ hashFiles('src/**/*.csproj') }}
          restore-keys: |
            nuget-${{ runner.os }}-

      - name: Cache Playwright browsers
        uses: actions/cache@v4
        id: playwright-cache
        with:
          path: ~/.cache/ms-playwright
          key: playwright-${{ runner.os }}-${{ hashFiles('src/AcceptanceTests/AcceptanceTests.csproj') }}
          restore-keys: |
            playwright-${{ runner.os }}-

      - name: Set Version
        run: |
          version="${{ env.MAJOR_VERSION }}.${{ env.MINOR_VERSION }}.${{ github.run_number }}"
          echo "BUILD_BUILDNUMBER=$version" >> $GITHUB_ENV

      - name: Run Acceptance Tests
        shell: pwsh
        env:
          BUILD_BUILDNUMBER: ${{ env.BUILD_BUILDNUMBER }}
        run: |
          Write-Host "Running Acceptance Tests"
          . ./build.ps1
          Invoke-AcceptanceTests

      - name: Test Reporter
        uses: dorny/test-reporter@v2.1.1
        if: always()
        with:
          name: Acceptance Test Results
          path: 'build/test/**/*.trx'
          reporter: dotnet-trx

      - name: Upload Test Results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results-acceptance
          path: build/test/**/*.trx
          retention-days: 2

  acceptance-tests-arm:
    name: Acceptance Tests (ARM SQLite)
    needs: [docker-build-image-for-churchbulletin-ui]
    if: success()
    runs-on: ubuntu-24.04-arm
    concurrency:
      group: acceptance-tests-arm-${{ github.ref }}
      cancel-in-progress: true
    permissions:
      contents: read
      packages: read
    env:
      BUILD_CONFIGURATION: Release
      DATABASE_ENGINE: SQLite

    steps:
      - name: Checkout code
        uses: actions/checkout@v6.0.1

      - name: Cache NuGet packages
        uses: actions/cache@v4
        with:
          path: ~/.nuget/packages
          key: nuget-${{ runner.os }}-arm-${{ hashFiles('src/**/*.csproj') }}
          restore-keys: |
            nuget-${{ runner.os }}-arm-

      - name: Cache Playwright browsers
        uses: actions/cache@v4
        id: playwright-cache
        with:
          path: ~/.cache/ms-playwright
          key: playwright-${{ runner.os }}-arm-${{ hashFiles('src/AcceptanceTests/AcceptanceTests.csproj') }}
          restore-keys: |
            playwright-${{ runner.os }}-arm-

      - name: Set Version
        run: |
          version="${{ env.MAJOR_VERSION }}.${{ env.MINOR_VERSION }}.${{ github.run_number }}"
          echo "BUILD_BUILDNUMBER=$version" >> $GITHUB_ENV

      - name: Run Acceptance Tests (ARM SQLite)
        shell: pwsh
        env:
          BUILD_BUILDNUMBER: ${{ env.BUILD_BUILDNUMBER }}
        run: |
          Write-Host "Running Acceptance Tests with SQLite on ARM"
          . ./build.ps1
          Invoke-AcceptanceTests -UseSqlite

      - name: Test Reporter
        uses: dorny/test-reporter@v2.1.1
        if: always()
        with:
          name: ARM Acceptance Test Results
          path: 'build/test/**/*.trx'
          reporter: dotnet-trx

      - name: Upload Test Results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results-acceptance-arm
          path: build/test/**/*.trx
          retention-days: 2

